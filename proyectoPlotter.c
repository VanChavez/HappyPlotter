/*

Name: Happy Plotter Project
Written by: Ivan Chavez Team.
Date: 2016-11-30
Version: "Last version working haha"

  Description: This program has been writen in C for a PIC Microcontroller "Microchip PIC10F887",
    the project has been build as final projet of microcontrollers university lecture.

    Happy Plotter Project idea begins when as a final project the professor demands to build a
    plotter using a PIC as microcontroller for this task we thought the plotter as a machine able to draw in a paper
    and as the draws/images digitally have a resolution as feature, we could build a 10x10 resolution plotter printer.

    Important note; The main program has been wrote in C and the other's code source files such as HEX and Assembly has been automatically generated by the IDE.

*/

/*
  In this part of the program we have defined all the variables we have use through the program due we use functions a lot and we wanted to avoid giving and recieveing parameters problems.
*/

int x, y, i, j, k;
char A1, BB1, C1, D1;

/*
All the const char arrays are the pre-defined draws we could select later in the main program here an example of an array:

{0,0,0,0,0,0,0,0,0,0}
{0,0,0,1,0,0,1,0,0,0}
{0,0,0,1,0,0,1,0,0,0}
{0,0,0,1,0,0,1,0,0,0}
{0,0,0,1,0,0,1,0,0,0}
{0,1,0,0,0,0,0,0,1,0}
{0,0,1,0,0,0,0,1,0,0}
{0,0,0,1,1,1,1,0,0,0}
{0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0}
-- if you pay attention to the 1's on the array you could notice it's a face figurem does it means the array 'Carita[10][10]' have pre-define the values and that allows to a general loop to print any figure as 10x10 resolution.
*/

const char circulo[10][10] = {{0,0,0,1,1,1,0,0,0,0},{0,0,1,0,0,0,1,0,0,0},{0,1,0,0,0,0,0,1,0,0},{1,0,0,0,0,0,0,0,1,0},{1,0,0,0,0,0,0,0,1,0},{1,0,0,0,0,0,0,0,1,0},{0,1,0,0,0,0,0,1,0,0},{0,0,1,0,0,0,1,0,0,0},{0,0,0,1,1,1,0,0,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char rectangulo[10][10] = {{0,0,1,1,1,1,1,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,1,1,1,1,1,0,0}};
const char cuadrado[10][10] = {{1,1,1,1,1,1,1,1,1,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,0,0,0,0,0,0,0,0,1},{1,1,1,1,1,1,1,1,1,1}};
const char triangulo[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0},{0,0,0,1,0,1,0,0,0,0},{0,0,1,0,0,0,1,0,0,0},{0,1,0,0,0,0,0,1,0,0},{1,1,1,1,1,1,1,1,1,0}};
const char Letra_A[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,1,1,1,1,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,1,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char Letra_B[10][10] = {{0,0,0,0,0,0,0,0,0,0},{ 0,0,0,0,1,1,1,1,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,0,1,1,1,1,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,1,0,0,0,0,1,0},{ 0,0,0,0,1,1,1,1,1,0}};
const char Letra_E[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,1,0,0,0},{0,1,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,0,0,0,0},{0,1,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char Letra_Y[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,1,0,0},{0,1,0,0,0,0,0,1,0,0},{0,1,0,0,0,0,0,1,0,0},{0,0,1,0,0,0,1,0,0,0},{0,0,0,1,0,1,0,0,0,0},{0,0,0,0,1,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0}};
const char Letra_P[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,1,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,0,1,1,1,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0}};
const char Letra_H[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,1,1,1,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0},{0,0,0,1,0,0,0,1,0,0}};
const char Letra_L[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1,0,0},{0,0,0,1,1,1,1,1,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char Letra_T[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,1,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char Letra_R[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,0,1,1,1,0,0,0},{0,0,0,0,1,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,0,0,0,0,0,0,0}};
const char Carita[10][10] = {{0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,0,0,1,0,0,1,0,0,0},{0,1,0,0,0,0,0,0,1,0},{0,0,1,0,0,0,0,1,0,0},{0,0,0,1,1,1,1,0,0,0},{0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0}};

//Pre-defining the functions we're going to use in this program, please notice the part 1 it's port configuring, part 2 are functions related to printing arragys & part 3 are those functions used for motor controlling.

//Part 1
void configuraPuertos();

//Part 2
void Fcirculo();
void Ftriangulo();
void Frectangulo();
void Fcuadrado();
void FLetra_A();
void FLetra_B();
void FLetra_E();
void FLetra_Y();
void FLetra_P();
void FLetra_H();
void FLetra_L();
void FLetra_T();
void FLetra_R();
void FCarita();

//Part 3
void Pintar_pixel();
void delay();
void Avanzaxp();
void Avanzayp();
void Avanzaxn();
void Avanzayn();
void Bajay();
void Regresax();
void Pintar_Cuadro();
void AvanceYparcial();


void main() {
      A1 = 0x08;
      BB1 = 0x04;
      C1 = 0x02;
      D1 = 0x01;
      /*
      The variables previously more than a software purpose have a hardware control pourpose, 
      the motors we have use are step motors so in order to handle each movement with the motor
      we have set the output values

      Step motor line wire output
      A B C D - HEX Value;
      1 0 0 0 - 0X08
      0 1 0 0 - 0x04
      0 0 1 0 - 0X02
      0 0 0 1 - 0x01

      Does it means to move forward or backwards using the motor we have output the voltage (Using H Bridges) in the A1-BB1-C1-D1 order.

      Please notice; This output are pretty linked to the hardware conexion has several test were runned before to define it as this way.

      */
      configuraPuertos(); //Calls Port Configure function
      
/*
This perma while function allows to the user to select the pre-defined array using 4 buttons as a binary array and 5th button input "PORTA.B4" 
in order to read the PORTA B0-B4 Pressed buttons.

PORTA INPUT - PORTA; Means port A while B# makes reference to a specific pin in the microcontroller

B4 B3 B2 B1 B0 | Figure
 0  0  0  0  1 | Carita array (Prints the face unsing 'Fcarita()')
 0  0  0  1  0 | Letter R printing function
 0  0  0  1  1 | Letter T printing function
 0  0  1  0  0 | Letter L printing function
 0  0  1  0  1 | Letter H printing function
      ...      |     ...

Please notice B4 Pin of PORTA is used in the while condition to read the B0-B3 pin input. 

*/
while(1){
         if(PORTA.B4 == 0){
            switch(PORTA){
            case 0x01: FCarita(); break;
            case 0x02: FLetra_R(); break;
            case 0x03: FLetra_T(); break;
            case 0x04: FLetra_L(); break;
            case 0x05: FLetra_H(); break;
            case 0x06: FLetra_P(); break;
            case 0x07: FLetra_Y(); break;
            case 0x08: FLetra_E(); break;
            case 0x09: FLetra_B(); break;
            case 0x0A: FLetra_A(); break;
            case 0x0B: Frectangulo(); break;
            case 0x0C: Ftriangulo(); break;
            case 0x0D: Fcuadrado(); break;
            case 0x0E: Fcirculo(); break;
            }}}}
//In this case the plotter is not able to stop or change the actual printing figure while running.


//This function configure the ports as a Output/Input and the working mode of the PIC, for more information please check the PIC16f887 spec sheets.
void configuraPuertos(){
    ANSELH = 0;
    ANSEL = 0;
    TRISD = 0x00;
    TRISA = 0xFF;
    TRISC = 0x00;
    TRISB = 0x01;
}

//-----------------Figures------------------------------------------------
//Please notice all the functions defined on Figures part have the same structure double for loop in order to sweep the array looking for 1's wich means it trigger the pixel printing function.
  void Fcirculo(){ 
 for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(circulo[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp(); //If the program doesn't find a 1 in the array it skips to the start position of the following array order.
  }
  //This functions indicates the plotter to move to the following position and starts to sweep in Y axis, i.e. 'Array[0][9]' has been reached.
  Regresax(); 
  Avanzayn();
 }
 }
  void Frectangulo(){
  for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(rectangulo[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void Fcuadrado(){
  for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(cuadrado[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void Ftriangulo(){
  for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(triangulo[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_A(){
  for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_A[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_B(){
 for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_B[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_E(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_E[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_Y(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_Y[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_P(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_P[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_H(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_H[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_L(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_L[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_T(){
for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_T[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FLetra_R(){
 for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Letra_R[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}
  void FCarita(){
  for(y=0;y<10;y++){
  for(x=0;x<10;x++){
      if(Carita[y][x] == 1){
        Pintar_pixel(); //Pixel printing
      }
      else
      Avanzaxp();
  }
  Regresax();
  Avanzayn();
 }}

//---------------------------Pixel printing function-------------------------
/*
This Pixel printing function is one of the most importat in the game due it contains the instructions needed by the hardware to be able to print a whole pixel.

  Important; Please notice it have a for loop and it's pourpouse is to match the distance of each motor due both have a different distance advacement in the controlling output.
*/
void Pintar_pixel(){
    for(k=0;k<7;k++){
     Avanzaxp();
     Bajay();
     Avanzaxn();
     Bajay();
     }
     Avanzaxp();
     Avanzayp();
}

 //---------------------------Funciones del motor-------------------------
void Avanzaxp(){        // Go forward in X axis 1 pixel | +X | ABCD
for(i = 3;i>0;i--){
        PORTC = A1; // A
        delay();
        PORTC = BB1; // B
        delay();
        PORTC = C1; // C
        delay();
        PORTC = D1; // D
        delay();
        PORTC = 0x00;
        }
}
void Avanzayp(){        // Go forward in Y axis 1 pixel | +Y | ABCD
for(i = 14;i>0;i--){
        PORTD = A1; // A
        delay();
        PORTD = BB1; // B
        delay();
        PORTD = C1; // C
        delay();
        PORTD = D1; // D
        delay();
        PORTD = 0x00;
        }
}
void Avanzaxn(){        // Go backward in X axis 1 pixel | -X | DCBA
for(i=0;i<3;i++){
     PORTC = D1; // D  //X en reversa
     delay();
     PORTC = C1; // C
     delay();
     PORTC = BB1; // B
     delay();
     PORTC = A1; // A
     delay();
     PORTC = 0x00;
     }
}
void Avanzayn(){       // Go backward in Y axis 1 pixel | -Y | DCBA
     for(i=0;i<14;i++){
        PORTD = D1; // D
        delay();
        PORTD = C1; // C
        delay();
        PORTD = BB1; // B
        delay();
        PORTD = A1; // A
        delay();
        PORTD = 0x00;
     }
}
void Bajay(){          // It go down in Y axis the minimum movement allowed using the DCBA output | Minimum advance -Y | DCBA
        PORTD = D1; // D
        delay();
        PORTD = C1; // C
        delay();
        PORTD = BB1; // B
        delay();
        PORTD = A1; // A
        delay();
        PORTD = 0x00;
        }
void Regresax(){         // It backs 10 pixels in X axis | -X | DCBA | This function is called when a row (X) in the array has reached its final output, i.e. "Array[0][9]""
for(i=30;i>0;i--){
        PORTC = D1; // D
        delay();
        PORTC = C1; // C
        delay();
        PORTC = BB1; // B
        delay();
        PORTC = A1; // A
        delay();
        PORTC = 0x00;
        }
}

/*
In order to standarize each delay between motor output controlling instrucctions (Hardware delay)
After running some test we have determinate 20ms works ok
*/
void delay(){
     delay_ms(20);
}
